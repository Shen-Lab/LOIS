#!/usr/bin/perl

############################################################################
#
# COPYRIGHT
#
# 2002 Massachusetts Institute of Technology
# All rights reserved.
#

use Getopt::Long;
use ICE::Structure;
use ICE::Utilities qw(trim);

my $program = "charmm_setup.prl";
my $authour = "David F. Green";
my $version = "0.9.5";
my $date = "15.06.2005";

my $filename = "";
my $intype = "CRD";
my $outroot = "output0";
my $patchfile = "";
my $resmodfile = "";
my $charmm = "charmm.exe";
my $verbose = 0;
my $topology = "topology.inp";
my $parameter = "parameter.inp";
my $run = 1;
my $hbuild = 1;
my $convert = 0;
my $accelrys = 0;

my $autogen_angles = 1;
my $autogen_dihedrals = 1;
my $diel_type = "rdiel";
my $eps = 4.0;
my $cutnb = 999;
my $ctofnb = 998;
my $ctonnb = 997;
my $wmin = 1.5;
my $e14fac = 1.0;
my $nbxmod = 5;
my $ecut_mode = "switch";
my $vcut_mode = "vswitch";
my $elec = 1;
my $vdw = 1;

&Process_Args();

my $structure = New ICE::Structure;

&Intro();

if (uc($intype) eq "CRD") {
    $structure->Read_CRD($filename);
}
elsif (uc($intype) eq "PDB") {
    $structure->Read_PDB($filename);
}
else {
    print STDERR "ERROR: Unrecognized input type $intype.\n";
    exit 0;
}

# This should be modified into a more robust solution. DFG
if (! $accelrys) {
    $structure->Convert_PDB_PARAM22();
}

if ($resmodfile ne "") {
    $structure->Read_Residue_Modification_File($resmodfile);
    $structure->Modify_Residues;
}
$structure->Distill();
if ($verbose) {
    $structure->Info();
}

foreach my $x (sort keys %{$structure->{'chain_info'}}) {
    my $seqfile = "$x.SEQ";
    my $fixresidfile = "${x}_FIXRES.INP";
    if ($verbose) {
	print "Chain ", $x, ":\n";
	print "\tSequence output to:         ", $seqfile, "\n";
	print "\tFix_Resid script output to: ", $fixresidfile, "\n"; 
    }
    $structure->Write_CHARMM_SEQ($x,$seqfile);
    $structure->Write_CHARMM_Fix_Resid($x,$fixresidfile);
}

# Write out CHARMM script
my $script_root = "setup";
open(CRDINP,">${script_root}.inp");

print CRDINP "* Auto-generated CHARMM script.\n";
print CRDINP "*\n";
print CRDINP "\n";
print CRDINP "! CHARMM input generated by charmm_setup.prl \n";
print CRDINP "! ========================================== \n";

print CRDINP "! Read in topology and parameter files\n";
print CRDINP "! ====================================\n";
print CRDINP "\n";
print CRDINP "open read unit 1 card name \"${topology}\"\n";
print CRDINP "read rtf card unit 1\n";
print CRDINP "close unit 1\n";
print CRDINP "\n";
print CRDINP "open read unit 1 card name \"${parameter}\"\n";
print CRDINP "read para card unit 1\n";
print CRDINP "close unit 1\n";
print CRDINP "\n";

# Read in non-water chains
foreach my $x (sort keys %{$structure->{'chain_info'}}) {
    if ($structure->{'chain_info'}->{$x}->{'type'} eq "Water") {
	next;
    }
    my $seqfile = "$x.SEQ";
    my $fixresidfile = "${x}_FIXRES.INP";
    my $first = "none";
    my $last = "none";
    my $options = "";
    if (! $autogen_angles ) {
	$options .= "noangle ";
    }
    if (! $autogen_dihedrals ) {
	$options .= "nodihedral ";
    }

    print CRDINP "open read unit 1 card name ", $seqfile, "\n";
    print CRDINP "read sequence unit 1 card\n";
    print CRDINP "close unit 1\n";
    
    # CHARMm (Accelrys) expects terminal patches to act on pre-patched residues.
    if ($accelrys) {
	if ($structure->{'chain_info'}->{$x}->{'type'} eq "Protein") {
	    $first = "NTER";
	    $last = "CTER";
	}
	elsif ($structure->{'chain_info'}->{$x}->{'type'} eq "Nucleic Acid") {
	    $first = "5TER";
	    $last = "3TER";
	}
    }

    print CRDINP "generate $x first $first last $last setup $options\n";
    print CRDINP "stream \"", $fixresidfile,"\"\n";
    print CRDINP "\n";

}

# Apply patches
if ($patchfile ne "") {
    my @run_first = ("BRK");
    $structure->Read_Patch_File($patchfile);
    # Some patches need to be run first
    foreach $key (sort keys %{$structure->{'assoc_data'}->{'patches'}} ) {
	foreach $value (@{$structure->{'assoc_data'}->{'patches'}->{$key}}) {
	    if ( grep(/^$value$/,@run_first) >= 1) {
		print CRDINP "patch $value $key setup\n";
	    }
	}
    }
    # Some patches need to be run first
    foreach $key (sort keys %{$structure->{'assoc_data'}->{'patches'}} ) {
	foreach $value (@{$structure->{'assoc_data'}->{'patches'}->{$key}}) {
	    if ( grep(/^$value$/,@run_first) == 0) {
		print CRDINP "patch $value $key setup\n";
	    }
	}
    }
    print CRDINP "\n";
    $structure->Write_Patch_File("$patchfile.v2");
}

#if ( $accelrys) {
#    system('echo A  16 NTER >> patch.inp.v2');
#    system('echo A 244 CTER >> patch.inp.v2');
#}

if ($autogen_angles && $autogen_dihedrals ) { 
    print CRDINP "autogenerate angles dihedrals\n";
}
elsif ($autogen_angles) {
    print CRDINP "autogenerate angles\n";
}
elsif ($autogen_dihedrals) {
    print CRDINP "autogenerate dihedrals\n";
}
print CRDINP "\n";

# Read in Water Chains
foreach my $x (sort keys %{$structure->{'chain_info'}}) {
    if ($structure->{'chain_info'}->{$x}->{'type'} ne "Water") {
	next;
    }

    my $seqfile = "$x.SEQ";
    my $fixresidfile = "${x}_FIXRES.INP";
    my $first = "none";
    my $last = "none";
    my $options = "noangle nodihedral";
    
    print CRDINP "open read unit 1 card name ", $seqfile, "\n";
    print CRDINP "read sequence unit 1 card\n";
    print CRDINP "close unit 1\n";

    print CRDINP "generate $x first $first last $last setup $options\n";
    print CRDINP "stream \"", $fixresidfile,"\"\n";
    print CRDINP "\n";
    
}
    
# Structure dependent loop
# ========================

print CRDINP &Output_CHARMM_Files($outroot);
if ($structure->{'frames'} == 0) {
    my $tmpfile = "setup_in.crd";
    $structure->Write_CRD($tmpfile);
    print CRDINP &Build_Structure_Call($tmpfile,$outroot);
}
else {
    for (my $i=1;$i<=$structure->{'frames'};$i++) {
	my $tmpfile = "setup_in_${i}.crd";
	my $tmp_title = $structure->Title();
	$structure->Title($tmp_title." Frame $i of $structure->{'frames'}\n");
	$structure->Write_CRD_Frame($i,$tmpfile);
	$structure->Title($tmp_title);
	print CRDINP &Build_Structure_Call($tmpfile,"${outroot}_${i}");
    }
}


# End structure dependent loop
# ============================

print CRDINP "stop\n";
print CRDINP "\n";
print CRDINP "! End generated CHARMM input\n";
print CRDINP "! ==========================\n";

close(CRDINP);
print STDERR "Generation of CHARMM HBUILD input complete.\n";

if ($run) {
    my $cmd = "${charmm} < ${script_root}.inp > ${script_root}.out";
    print STDERR "Running CHARMM ... ";
    system($cmd);
    print STDERR "done.\n";
    &Analyze_CHARMM_Log("${script_root}.out");
}
else {
    print "CHARMM script written to ${script_root}.inp.\n";
}

if ($convert) {
    if ($structure->{'frames'} == 0) {
	&Convert_Parameters("CHARMM19",$outroot);
	&Convert_Parameters("PARSE",$outroot);
	&Convert_Parameters("PARMESAN",$outroot);
    }
    else {
	for (my $i=1;$i<=$structure->{'frames'};$i++) {
	    &Convert_Parameters("CHARMM19","${outroot}_${i}");
	    &Convert_Parameters("PARSE","${outroot}_${i}");
	    &Convert_Parameters("PARMESAN","${outroot}_${i}");
	}
    }
}

&Overview();

exit 0;

##############################################################################
#
sub Intro {
    printf "\n";
    printf "%+15s : %-20s\n", "Program",$program;
    printf "%+15s : %-20s\n", "Authour",$authour;
    printf "%+15s : %-20s\n", "Version",$version;
    printf "%+15s : %-20s\n", "Release Date",$date;
    printf "\n";
    printf "%+15s : %-20s\n", "Machine", $ENV{'HOSTNAME'};
    printf "%+15s : %-20s\n", "Run Date", scalar(localtime(time()));
    printf "\n";
    return;
}
#
##############################################################################

##############################################################################
#
sub Process_Args {
    my $help = 0;

    my $cdiel = 0;
    my $rdiel = 0;
    my $switch = 0;
    my $shift = 0;
    my $fswitch = 0;
    my $fshift = 0;
    my $vswitch = 0;
    my $vshift = 0;

    my $status = &GetOptions( "if=s"  => \$filename,
			      "it=s"  => \$intype,
			      "of=s"  => \$outroot,
			      "tf=s"  => \$topology,
			      "pf=s"  => \$parameter,
			      "patch=s" => \$patchfile,
			      "resmod=s" => \$resmodfile,
			      "charmm=s" => \$charmm,
			      "run!"=> \$run,
			      "hbuild!"=>\$hbuild,
			      "convert!" => \$convert,
			      "accelrys" => \$accelrys,
			      "v" => \$verbose,
			      "h" => \$help,
			      "autogen_angles!" => \$autogen_angles,
			      "autogen_dihedrals!" => \$autogen_dihedrals,
			      "cdiel" => \$cdiel,
			      "rdiel" => \$rdiel,
			      "eps=f" => \$eps,
			      "cutnb=f" => \$cutnb,
			      "ctofb=f" => \$ctofnb,
			      "ctonnb=f" => \$ctonnb,
			      "wmin=f" => \$wmin,
			      "e14fac=f" => \$e14fac,
			      "nbxmod=i" => \$nbxmod,
			      "switch" => \$switch,
			      "shift" => \$shift,
			      "fswitch" => \$fswitch,
			      "fshift" => \$fshift,
			      "vswitch" => \$vswitch,
			      "vshift" => \$vshift,
			      "elec!" => \$elec,
			      "vdw!" => \$vdw
			      );
    
    if ( ! $status ) {
	print STDERR "SYNTAX ERROR.\n";
	&Syntax();
    }
    
    if ($help) {
	&Syntax();
    }

    if ($cdiel && $rdiel) {
	print STDERR "ERROR: Both constant and distance dependent dielectric specified.\n";
	&Syntax();
    }
    elsif ($cdiel) {
	$diel_type = "cdiel";
    }
    elsif ($rdiel) {
	$diel_type = "rdiel";
    }

    if ( ($switch + $shift + $fswitch + $fshift ) > 1) {
	print STDERR "ERROR: Multiple electrostatic cutoff behaviours specified.\n";
	&Syntax();
    }
    elsif ($switch) {
	$ecut_mode = "switch";
    }
    elsif ($shift) {
	$ecut_mode = "shift";
    }
    elsif ($fswitch) {
	$ecut_mode = "fswitch";
    }
    elsif ($fshift) {
	$ecut_mode = "fshift";
    }

    if ($vswitch && $vshift) {
	print STDERR "ERROR: Multiple van der Waals cutoff behaviours specified.\n";
	&Syntax();
    }
    elsif ($vswitch) {
	$vcut_mode = "vswitch";
    }
    elsif ($vshift) {
	$vcut_mode = "vshift";
    }

    # Obtain CRD file name 
    if ( ! defined $ARGV[0] ) {
	if ($filename eq "") {
	    print "Please enter a crd file name: ";
	    $filename = <STDIN>;
	    chomp($filename);
	}
    }
    else {
	$filename = $ARGV[0];
    }
    
    if ($patchfile ne "" && ! -e $patchfile) {
	print STDERR "ERROR: Patch file $patchfile does not exist.\n";
	&Syntax();
    }

    # Check for existance of CRD file
    if ( ! -e $filename ) {
	print "ERROR:  Cannot find CRD file $filename.\n";
	&Syntax();
	exit 0;
    }

    return;
}
#
##############################################################################

##############################################################################
#
sub Syntax {
    print STDERR "\n";
    print STDERR "USAGE:   $program [options] [charmm_options]\n";
    print STDERR "\n";
    print STDERR "OPTIONS: -if infile       Input file name.\n"; 
    print STDERR "         -it intype       Input file type (CRD or PDB).\n";
    print STDERR "         -of intype       Root name for output files.\n";
    print STDERR "         -tf parameter file.\n";
    print STDERR "                          CHARMM topology file.\n";
    print STDERR "         -pf parameter file.\n";
    print STDERR "                          CHARMM parameter file.\n";
    print STDERR "         -patch patchfile Name of patch file.  This file may be in\n";
    print STDERR "                          any of several formats, although the preferred\n";
    print STDERR "                          format is CHARMM-style (PATC patch segid resid),\n";
    print STDERR "                          (PATC patch segid1 resid1 segid2 resid2).  Use of\n";
    print STDERR "                          this format will ensure proper behaviour within\n";
    print STDERR "                          CHARMM of disulfide patches.\n";
    print STDERR "         -resmod resfile  Name of residue modification file.  This file\n";
    print STDERR "                          lists Asn,Gln,His residues to flip, with the\n";
    print STDERR "                          syntax \"SEGID RESID RESNAME flip\", and lists\n";
    print STDERR "                          protonation states with the syntax \"SEGID RESID\n";
    print STDERR "                          RESNAME\", where resname is the name of the\n";
    print STDERR "                          residue with the desired protonation state (e.g.\n";
    print STDERR "                          HSP).  For histidines, a single line defining the\n";
    print STDERR "                          protonation state and the flip state is acceptable.\n";
    print STDERR "         -charmm charmm_exec\n";
    print STDDER "                           Sets the location of the charmm executable.\n";
    print STDERR "         -[no]run          Toggle execution of CHARMM script (defaults to ON).\n";
    print STDERR "         -[no]hbuild       Toggle execution of HBUILD commands in CHARMM script.\n";
    print STDERR "                           Turning this option off allows for processing of an\n";
    print STDERR "                           NMR structure (or other structure with hydrogens)\n";
    print STDERR "                           into a CHARMM-ready format, without changing any\n";
    print STDERR "                           coordinates (defaults to ON).\n";
    print STDERR "         -[no]convert      Toggle conversion of output files to multiple parameter\n";
    print STDERR "                           sets after build (defaults to OFF).\n";
    print STDERR "         -v                Enable verbose output.\n";
    print STDERR "         -h                Print this message.\n";
    print STDERR "         -accelrys         Flag to use the Accelrys CHARMm special options.\n";
    print STDERR "\n";
    print STDERR "CHARMM OPTIONS:\n"; 
    print STDERR "         -[no]autogen_angles\n";
    print STDERR "                           Toggle autogeneration of angles (defaults to ON).\n";
    print STDERR "         -[no]autogen_dihedrals\n";
    print STDERR "                           Toggle autogeneration of dihedrals (defaults to ON).\n";
    print STDERR "         -cdiel            Use constant dielectric electrostatics.\n";
    print STDERR "         -rdiel            Use distance-dependent dielectric electrostatics.\n";
    print STDERR "         -eps value        Set dielectric constant to value.\n";
    print STDERR "         -cutnb value      Set non-bond cutoff to value.\n";
    print STDERR "         -ctofnb value     Non-bond energies smoothed to zero at value.\n";
    print STDERR "         -ctonnb value     Non-bond energies smoothing begins at value.\n";
    print STDERR "         -wmin value       Set warning distance for close contacts to value.\n";
    print STDERR "         -e14fac value     Set 1-4 non-bond energy scaling to value.\n";
    print STDERR "         -nbxmod value     Set non-bond exculsion mode (0-5).\n";
    print STDERR "         -switch           Switch electrostatic energies to zero at cutoff.\n";
    print STDERR "         -shift            Shift electrostatic energy function to zero at cutoff.\n";
    print STDERR "         -fswitch          Switch electrostatic forces to zero at cutoff.\n";
    print STDERR "         -fshift           Shift electrostatic force function to zero at cutoff.\n";
    print STDERR "         -vswitch          Switch van der Waals energies to zero at cutoff.\n";
    print STDERR "         -vshift           Shift van der Waals energy function to zero at cutoff.\n";
    print STDERR "         -[no]elec         Toggle inclusion of electrostatic energies.\n";
    print STDERR "         -[no]vdw          Toggle inclusion of van der Waals energies.\n";
    print STDERR "\n";

    exit 0;   
}
#
##############################################################################

##############################################################################
#
sub Overview {
    
    print STDERR "\n"; 
    print STDERR "*** IMPORTANT INFORMATION ***\n";
    print STDERR "\n";
    print STDERR "You have just automagically generated an H-built structure, CHARMM PSF, and\n";
    print STDERR "CHARMM IC table.  As the accuracy of these files will affect all further\n";
    print STDERR "calculations, this step should be cautiously reviewed.  By default, all\n";
    print STDERR "are unpatched, unless a patch file is present and specified.  This is true\n";
    print STDERR "for N- and C-terminal patches as well as others.  Waters are generated with\n";
    print STDERR "noangle and nodihedral.  Remember that some atom names are different in various\n";
    print STDERR "parameter sets, and in the PBD, for example ILE CD in PARAM22 is CD1 in the\n";
    print STDERR "PDB and water oxygens are named HOH O in the PDB.  Some of these are auto-\n";
    print STDERR "magically converted to the PARAM22 standard, but, as always, there may be more,\n";
    print STDERR "CHECK THE LOG!  By default, the script is designed to run with autogeneration \n";
    print STDERR "of angles and dihedrals from the bond list.  If this is not the desired mode of\n";
    print STDERR "operation, the -noautogen_angles and -noautogen_dihedrals command-line options\n";
    print STDERR "should be used.  The generated script ${script_root}.inp may be editted and\n";
    print STDERR "rerun by hand if desired.\n";
    print STDERR "\n";
    print STDERR "*** IMPORTANT INFORMATION ***\n";
    print STDERR "\n";
    return;
}
#
##############################################################################

##############################################################################
#
sub HBuild_Call {
    my $string = "hbuild sele hydrogen end -\n";
    if ($elec) {
	$string .= "  elec atom $diel_type $ecut_mode eps $eps -\n";
    }
    else {
	$string .= "  noelec -\n";
    }
    if ($vdw) {
	$string .= "  vdw vatom $vcut_mode -\n";
    }
    else {
	$string .= "  novdw -\n";
    }
    $string .= "  cutnb $cutnb ctofnb $ctofnb ctonnb $ctonnb wmin $wmin -\n";
    $string .= "  e14fac $e14fac nbxmod $nbxmod\n";
    return $string;
}
#
##############################################################################

##############################################################################
#
sub Output_CHARMM_Files {
    my $root = shift;
    
    my $string = "scalar wmain = charge\n";
    $string   .= "\n";
    $string   .= "open write unit 1 card name ${root}.psf\n";
    $string   .= "write psf card unit 1\n";
    # Unit closed automatically after write.
    #$string   .= "close unit 1\n";
    $string   .= "\n";
    $string   .= "open write unit 1 card name ${root}.ic\n";
    $string   .= "write ic card unit 1\n";
    # Unit closed automatically after write.
    #$string   .= "close unit 1\n";
    $string   .= "\n";

    return $string;
}
#
##############################################################################

##############################################################################
#
sub Output_CHARMM_Coordinates {
    my $root = shift;
    
    my $string = "scalar wmain = charge\n";
    $string   .= "\n";
    $string   .= "open write unit 1 card name ${root}.crd\n";
    $string   .= "write coor card unit 1\n";
    # Unit closed automatically after write.
    #$string   .= "close unit 1\n";
    $string   .= "\n";

    return $string;
}
#
##############################################################################

##############################################################################
#
sub Build_Structure_Call {
    my $coor = shift;
    my $root = shift;
    
    my $string = "";

    $string .= "open read unit 1 card name ${coor} \n";
    $string .= "read coor card unit 1 resid\n";
    $string .= "close unit 1\n";
    $string .= "\n";
    
# Build missing heavy atoms
    $string .= "! Check for and build in missing heavy atoms\n";
    $string .= "! Build is done into default geometry from parameter file.\n";
    $string .= "! ==========================================\n";
    $string .= "\n";
    $string .= "define missing1 sele .not. ( init .or. hydrogen ) end\n";
    $string .= "if ?nsel ne 0 print coor sele missing1 end\n";
    $string .= "\n";
    $string .= "ic param\n";
    $string .= "ic fill preserve\n";
    $string .= "ic build\n";
    $string .= "\n";
    $string .= "define missing2 sele .not. ( init .or. hydrogen ) end\n";
    $string .= "if ?nsel ne 0 print coor sele missing2 end\n";
    $string .= "\n";
    
# Do H-build
    if ($hbuild) {
	$string .= "! Build hydrogens\n";
	$string .= "! Default parameters are rdiel of 4, with no cutoffs.\n";
	$string .= "! ===================================================\n";
	$string .= "\n";
	$string .= &HBuild_Call();
	$string .= "\n";
	$string .= &HBuild_Call();
	$string .= "\n";
    }
    else {
	$string .= "! NOT building hydrogens, output structures are same as input\n";
	$string .= "\n";
    }
    # Test energies
    $string .= "update\n";
#    $string .= "inter sele missing1 end sele .not. ( missing1 .or. hydrogen ) end\n";
    $string .= "\n";
# Write out structure
    $string .= "! Write out structure, ic table and coordinates.\n";
    $string .= "! ==============================================\n";
    $string .= "\n";
    $string .= &Output_CHARMM_Coordinates($root);
    $string .= "\n";

    return $string;
}

sub Analyze_CHARMM_Log {
    my $logfile = shift;
    open(LOG,$logfile);
    
    my %warnings = ();
    my $max_warn;
    my $success = 0;
    my @missing_volumes = ();
    while (<LOG>) {
	chomp;
	if ( /NORMAL TERMINATION BY NORMAL STOP/) {
	    $success = 1;
	}
	if ( /PARRDR> WARNING: ATOM FOR VOLUME/) {
	    my $atom = trim(substr($_,34,4));
	    push(@missing_volumes,$atom);
	} 
	elsif (/MOST SEVERE WARNING WAS AT LEVEL/ ) {
	    s/MOST SEVERE WARNING WAS AT LEVEL//;
	    $max_warn = trim($_);
	}
#	elsif (/*** LEVEL/ && /WARNING *** BOMLEV IS/ ) {
	    # Summary warning, skip
	    # Skip
#	}
	elsif ( /WARNING/ ) {
	    if (! defined $warnings{$_}) { 
		$warnings{$_} = 0;
	    }
	    $warnings{$_} ++;
	}
    }
    close(LOG);

    print "\n=======================================================\n";
    print "The following warnings were detected in the CHARMM log:\n";
    foreach $warning (keys %warnings) {
	printf "%3d: %s\n",$warnings{$warning}, $warning;
    }
    print "-------------------------------------------------------\n";
    print "Missing volumes:";
    foreach $x (sort @missing_volumes) {
	print " $x";
    }
    print "\n";
    print "=======================================================\n";
    if ($success) {
	print " CHARMM terminated normally, build likely successful\n";
	print " Worst warning was at level ${max_warn}.\n";
    }
    else {
	print " **** CHARMM terminated abnormally -- build unsuccessful ****\n";
    }
    print "=======================================================\n\n";
    return;
}

sub Convert_Parameters {
    my $param = shift;
    my $root = shift;

    my $infile = $root.".crd";
    my $outfile = $root."_".lc($param).".crd";

    my $crdconvert = "/usr/people/dfgreen/Development/software/ice/scripts/crdconvert.prl";
    my $table = "/usr/people/dfgreen/param/parameter_translation_table";

    my $inparam;
    if ( $accelrys) {
	$inparam = "CHARMm";
    }
    else {
	$inparam = "CHARMM22";
    }
    my $cmd = "$crdconvert -ic $infile -oc $outfile -ip $inparam -op $param -patch patch.inp.v2 -table $table -nodel";
    system($cmd);

    return;
}
